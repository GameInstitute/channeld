syntax = "proto3";

package channeld;

import "google/protobuf/any.proto";

option go_package = "/proto";

// The data packet that is sent between the endpoints. A packet can have multiple messages in the payload in one trip to improve the efficiency.
message Packet {
    repeated MessagePack messages = 1;
}

// The serialized message and the context of it.
message MessagePack {
    // The channel that the message is sent to.
    // 0 means the message should be handled in the global channel (e.g. a @CreateChannel message)
    uint32 channelId = 1;

    // Will the message be broadcasted to all connections in the channel? 
    // ONLY works for the user-space messages. 
    BroadcastType broadcast = 2;

    // The stub for RPC callbacks.
    // 0 means the packet is not a RPC message.
    uint32 stubId = 3;

    // The MessageType either defined in @MessageType enum, or defined in user space.
    uint32 msgType = 4;

    // Protobuf-marshalled message body.
    bytes msgBody = 5;
}

enum BroadcastType {
    // No broadcast. All internal messages should use this type, and other types are ignored.
    NO = 0;
    // Broadcast the message to all the connections in the channel, the sender included.
    ALL = 1;
    // Broadcast the message to all the connections in the channel, the sender excluded.
    ALL_BUT_SENDER = 2;
    // Forward the packet to the connection. Can only be used by the backend server. The channelId in the packet will then be used as the target connectionId.
    // This has the same behavior as sending the packet to the PRIVATE channel owned by the target connection with BroadcastType = NO, but is less efficient as the message will be handled in the global channel.
    SINGLE_CONNECTION = 3; 
}

enum ChannelType {
    UNKNOWN = 0;
    GLOBAL = 1;   // Default channel. Any message without ChannelId specified will be sent to this channel.
    PRIVATE = 2;  // Per-connection channel. Useful to store the user data and subscribe the client to the data update.
    SUBWORLD = 3; // A game "room" in a session-based game, or a level in an MMORPG. Subworlds are spatially divided thus the interests are isolated.
    SPATIAL = 4;  // Spatial channels are spatailly connected. Using this channel to implement a seamless open world.
    TEST = 100;   // The following are for tests.
    TEST1 = 101;
    TEST2 = 102;
    TEST3 = 103;
    TEST4 = 104;
}

enum MessageType {
    INVALID = 0;
    AUTH = 1;
    //AUTH_RESULT = 2;
    CREATE_CHANNEL = 3;
    REMOVE_CHANNEL = 4;
    LIST_CHANNEL = 5;
    SUB_TO_CHANNEL = 6;
    UNSUB_FROM_CHANNEL = 7;
    CHANNEL_DATA_UPDATE = 8;
    DISCONNECT = 9;
    USER_SPACE_START = 100;
}

// Messages that are not handled in channeld. DO NOT send this message directly to channeld, as channeld uses it to wrap the payload and forward it to the target endpoint(s).
message UserSpaceMessage {
    // The backend server generally needs the client connId to identify the sender.
    uint32 sourceConnId = 1;
    // The user (client/server) decides to how serialize/deserialize the message.
    bytes payload = 2;
}

// The packet should have channelId = 0 in order to be handled.
// Response: @AuthResultMessage
message AuthMessage {
    string playerIdentifierToken = 1;
    string loginToken = 2;
}

message AuthResultMessage {
    enum AuthResult {
        SUCCESSFUL = 0;
        INVALID_PIT = 1;
        INVALID_LT = 2;
    }
    AuthResult result = 1;
    uint32 connId = 2;
}

message ChannelSubscriptionOptions {
	bool CanUpdateData = 1;
	repeated string DataFieldMasks = 2;
	uint32 FanOutIntervalMs = 3;
}

// The packet should have channelId = 0 in order to be handled.
// Response: @SubscribedToChannelsMessage
message CreateChannelMessage {
    ChannelType channelType = 1;
    string metadata = 2;
    ChannelSubscriptionOptions subOptions = 3;
    google.protobuf.Any data = 4;
}

// The packet should have channelId = 0 in order to be handled.
// Response: all connections in the channel will receive @RemoveChannelMessage
message RemoveChannelMessage {
    uint32 channelId = 1;
}

// The packet should have channelId = 0 in order to be handled.
// Response: @ListChannelResultMessage
message ListChannelMessage {
    ChannelType typeFilter = 1;
    repeated string metadataFilters = 2;
}

message ListChannelResultMessage {
    message ChannelInfo {
        uint32 channelId = 1;
        ChannelType channelType = 2;
        string metadata = 3;
    }
    repeated ChannelInfo channels = 1;
}

// Response: @SubscribedToChannelMessage. The channel owner will receive the same message.
message SubscribedToChannelMessage {
    // The connection to be added to the channel is not necessarily the one sends the message 
    uint32 connId = 1;
    ChannelSubscriptionOptions subOptions = 2;
}

// Response: @UnsubscribedFromChannelMessage. The channel owner will receive the same message.
message UnsubscribedFromChannelMessage {
    uint32 connId = 1;
}

// Response: no. Each connection in the channel receives the @ChannelDataUpdateMessage in every @ChannelSubscriptionOptions.FanOutIntervalMs
message ChannelDataUpdateMessage {
    google.protobuf.Any data = 1;
}

// Disconnect another connection from channeld. 
// This message should only be sent by the server connection in a server-authoratative environment.
// The packet should have channelId = 0 in order to be handled.
// Response: no.
message DisconnectMessage {
    uint32 connId = 1;
}


message Location {
    double x = 1;
    double y = 2;
    double z = 3;
}

message SpatialEntityInfo {
    Location loc = 1;
}

message SpatialChannelDataMessage {
    map<uint32, SpatialEntityInfo> entities = 1;
}